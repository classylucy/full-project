name: Comprehensive CI/CD Workflow

on:
  push:
    branches: [ main, develop, feature/**, hotfix/**, release/** ]
  pull_request:
    branches: [ main, develop ]

jobs:
  detect-and-deploy:
    runs-on: ubuntu-latest
    
    env:
      # Default environment variables
      ENVIRONMENT: development
      DEPLOY_STRATEGY: rolling
      CONTAINER_REGISTRY: ghcr.io
      # Cloud provider config
      CLOUD_PROVIDER: azure  # or aws
      # DevOps tooling
      MONITORING_TOOL: prometheus
      LOGGING_TOOL: elk
      NOTIFICATION_CHANNEL: slack
      
    steps:
      # ---- PROJECT INITIALIZATION ----
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper versioning
      
      - name: Determine environment from branch
        id: determine-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
            echo "DEPLOY_STRATEGY=blue-green" >> $GITHUB_ENV
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/release/"* ]]; then
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
            echo "DEPLOY_STRATEGY=canary" >> $GITHUB_ENV
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "ENVIRONMENT=testing" >> $GITHUB_ENV
            echo "environment=testing" >> $GITHUB_OUTPUT
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
            echo "environment=development" >> $GITHUB_OUTPUT
          fi
      
      # ---- PROJECT DETECTION ----
      - name: Detect project type
        id: project-detection
        run: |
          # Project type detection logic
          if [ -f "package.json" ]; then
            if [ -f "angular.json" ]; then
              echo "PROJECT_TYPE=angular" >> $GITHUB_ENV
              echo "project_type=angular" >> $GITHUB_OUTPUT
            elif [ -f "next.config.js" ]; then
              echo "PROJECT_TYPE=nextjs" >> $GITHUB_ENV
              echo "project_type=nextjs" >> $GITHUB_OUTPUT
            elif [ -f "nuxt.config.js" ]; then
              echo "PROJECT_TYPE=nuxtjs" >> $GITHUB_ENV
              echo "project_type=nuxtjs" >> $GITHUB_OUTPUT
            elif [ -f "react-scripts.config.js" ] || grep -q "react-scripts" package.json || [ -f "src/App.jsx" ] || [ -f "src/App.tsx" ] || [ -f "src/index.jsx" ] || [ -f "src/index.tsx" ]; then
              echo "PROJECT_TYPE=react" >> $GITHUB_ENV
              echo "project_type=react" >> $GITHUB_OUTPUT
            else
              echo "PROJECT_TYPE=nodejs" >> $GITHUB_ENV
              echo "project_type=nodejs" >> $GITHUB_OUTPUT
            fi
          elif [ -f "pom.xml" ]; then
            echo "PROJECT_TYPE=java-maven" >> $GITHUB_ENV
            echo "project_type=java-maven" >> $GITHUB_OUTPUT
          elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            echo "PROJECT_TYPE=java-gradle" >> $GITHUB_ENV
            echo "project_type=java-gradle" >> $GITHUB_OUTPUT
          elif [ -f "go.mod" ]; then
            echo "PROJECT_TYPE=golang" >> $GITHUB_ENV
            echo "project_type=golang" >> $GITHUB_OUTPUT
          elif [ -d ".net" ] || [ -f "*.csproj" ]; then
            echo "PROJECT_TYPE=dotnet" >> $GITHUB_ENV
            echo "project_type=dotnet" >> $GITHUB_OUTPUT
          elif [ -f "requirements.txt" ] || [ -f "setup.py" ] || [ -f "Pipfile" ]; then
            echo "PROJECT_TYPE=python" >> $GITHUB_ENV
            echo "project_type=python" >> $GITHUB_OUTPUT
          elif [ -f "Cargo.toml" ]; then
            echo "PROJECT_TYPE=rust" >> $GITHUB_ENV
            echo "project_type=rust" >> $GITHUB_OUTPUT
          elif [ -f "composer.json" ]; then
            echo "PROJECT_TYPE=php" >> $GITHUB_ENV
            echo "project_type=php" >> $GITHUB_OUTPUT
          else
            echo "PROJECT_TYPE=generic" >> $GITHUB_ENV
            echo "project_type=generic" >> $GITHUB_OUTPUT
          fi
          
          # Detect containerization
          if [ -f "Dockerfile" ] || [ -f "docker-compose.yml" ]; then
            echo "CONTAINERIZED=true" >> $GITHUB_ENV
            echo "containerized=true" >> $GITHUB_OUTPUT
          else
            echo "CONTAINERIZED=false" >> $GITHUB_ENV
            echo "containerized=false" >> $GITHUB_OUTPUT
          fi
          
          # Detect legacy components
          if [ -f "legacy_marker.txt" ] || grep -q "legacy" package.json 2>/dev/null; then
            echo "HAS_LEGACY=true" >> $GITHUB_ENV
            echo "has_legacy=true" >> $GITHUB_OUTPUT
          else
            echo "HAS_LEGACY=false" >> $GITHUB_ENV
            echo "has_legacy=false" >> $GITHUB_OUTPUT
          fi
          
          echo "Detected project type: ${{ env.PROJECT_TYPE }}"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Containerized: ${{ env.CONTAINERIZED }}"
          echo "Has legacy components: ${{ env.HAS_LEGACY }}"

      # ---- LOAD CONFIGURATION ----
      - name: Load environment configuration
        id: config
        run: |
          # In a real scenario, these configurations would be stored securely
          # Maybe they would be encrypted in the repo or stored in GitHub Secrets
          
          echo "Loading configuration for ${{ env.ENVIRONMENT }} environment"
          
          # Example of loading different configs based on environment
          if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
            echo "API_URL=https://api.example.com" >> $GITHUB_ENV
            echo "CDN_URL=https://cdn.example.com" >> $GITHUB_ENV
            echo "ENABLE_MONITORING=true" >> $GITHUB_ENV
          elif [[ "${{ env.ENVIRONMENT }}" == "staging" ]]; then
            echo "API_URL=https://api-staging.example.com" >> $GITHUB_ENV
            echo "CDN_URL=https://cdn-staging.example.com" >> $GITHUB_ENV
            echo "ENABLE_MONITORING=true" >> $GITHUB_ENV
          else
            echo "API_URL=https://api-dev.example.com" >> $GITHUB_ENV
            echo "CDN_URL=https://cdn-dev.example.com" >> $GITHUB_ENV
            echo "ENABLE_MONITORING=false" >> $GITHUB_ENV
          fi

      # ---- SETUP BUILD ENVIRONMENT ----
      - name: Setup build environment
        run: |
          echo "Setting up build environment for ${{ env.PROJECT_TYPE }}"
          
          case ${{ env.PROJECT_TYPE }} in
            nodejs|angular|nextjs|nuxtjs)
              echo "Setting up Node.js"
              if [[ $(grep -w "node" package.json | grep -o "[0-9.]*") ]]; then
                NODE_VERSION=$(grep -w "node" package.json | grep -o "[0-9.]*")
              else
                NODE_VERSION="18.x"
              fi
              echo "Using Node.js version $NODE_VERSION"
              ;;
            python)
              echo "Setting up Python"
              PYTHON_VERSION=$(grep -w "python_version" Pipfile 2>/dev/null | grep -o "[0-9.]*" || echo "3.10")
              echo "Using Python version $PYTHON_VERSION"
              ;;
            java-maven|java-gradle)
              echo "Setting up Java"
              JAVA_VERSION=$(grep -w "<java.version>" pom.xml 2>/dev/null | grep -o "[0-9.]*" || echo "17")
              echo "Using Java version $JAVA_VERSION"
              ;;
            # Add more project types as needed
          esac
      
      # ---- INSTALL DEPENDENCIES ----
      - name: Set up Node.js
        if: env.PROJECT_TYPE == 'nodejs' || env.PROJECT_TYPE == 'angular' || env.PROJECT_TYPE == 'nextjs' || env.PROJECT_TYPE == 'nuxtjs'
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'npm'
          
      - name: Set up Python
        if: env.PROJECT_TYPE == 'python'
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'
          
      - name: Set up Java
        if: env.PROJECT_TYPE == 'java-maven' || env.PROJECT_TYPE == 'java-gradle'
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: ${{ env.PROJECT_TYPE == 'java-maven' && 'maven' || 'gradle' }}
          
      - name: Set up .NET
        if: env.PROJECT_TYPE == 'dotnet'
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '6.0.x'
          
      - name: Set up Go
        if: env.PROJECT_TYPE == 'golang'
        uses: actions/setup-go@v4
        with:
          go-version: '1.20'
          
      - name: Install dependencies
        run: |
          echo "Installing dependencies for ${{ env.PROJECT_TYPE }}"
          
          case ${{ env.PROJECT_TYPE }} in
            nodejs|angular|nextjs|nuxtjs)
              if [ -f "yarn.lock" ]; then
                yarn install --frozen-lockfile
              else
                npm ci
              fi
              ;;
            python)
              if [ -f "requirements.txt" ]; then
                pip install -r requirements.txt
              elif [ -f "Pipfile" ]; then
                pip install pipenv && pipenv install --dev
              elif [ -f "setup.py" ]; then
                pip install -e .
              fi
              ;;
            java-maven)
              mvn dependency:go-offline
              ;;
            java-gradle)
              ./gradlew dependencies
              ;;
            golang)
              go mod download
              ;;
            dotnet)
              dotnet restore
              ;;
            php)
              composer install --no-interaction --prefer-dist
              ;;
            rust)
              cargo fetch
              ;;
          esac

      # ---- HANDLE LEGACY COMPONENTS ----
      - name: Handle legacy components
        if: env.HAS_LEGACY == 'true'
        run: |
          echo "Handling legacy components"
          
          # Example legacy component handling
          if [ -f "legacy_marker.txt" ]; then
            # Example: Apply patches or special configurations for legacy code
            echo "Applying legacy patches"
            
            # This is just a placeholder. In a real scenario, you might:
            # 1. Apply configuration patches
            # 2. Set up compatibility layers
            # 3. Adjust build flags for older compilers
            # 4. Include polyfills
            if [ -f "legacy-patches/apply.sh" ]; then
              bash legacy-patches/apply.sh
            fi
          fi

      # ---- STATIC CODE ANALYSIS ----
      - name: Run static code analysis
        run: |
          echo "Running static code analysis for ${{ env.PROJECT_TYPE }}"
          
          case ${{ env.PROJECT_TYPE }} in
            nodejs|angular|nextjs|nuxtjs)
              if [ -f ".eslintrc" ] || [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ]; then
                npm run lint || echo "Linting errors detected"
              fi
              ;;
            python)
              if [ -f ".flake8" ] || [ -f "setup.cfg" ] || [ -f "tox.ini" ]; then
                pip install flake8 && flake8 || echo "Flake8 errors detected"
              fi
              if [ -f "mypy.ini" ]; then
                pip install mypy && mypy . || echo "Type errors detected"
              fi
              ;;
            java-maven|java-gradle)
              if [ -f "checkstyle.xml" ]; then
                echo "Running Checkstyle"
                # Execute appropriate checkstyle command based on build system
              fi
              ;;
            golang)
              go vet ./... || echo "Go vet found issues"
              ;;
            # Add more project types as needed
          esac

      # ---- BUILD PROCESS ----
      - name: Build application
        id: build
        run: |
          echo "Building application for ${{ env.PROJECT_TYPE }} in ${{ env.ENVIRONMENT }} environment"
          
          # Set build-specific environment variables based on environment
          if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
            export NODE_ENV=production
            export OPTIMIZE_BUILD=true
          else
            export NODE_ENV=development
            export OPTIMIZE_BUILD=false
          fi
          
          case ${{ env.PROJECT_TYPE }} in
            nodejs)
              if [ -f "package.json" ] && grep -q "build" package.json; then
                npm run build
              fi
              ;;
            angular)
              if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                npm run build -- --configuration production
              else
                npm run build
              fi
              ;;
            react)
              if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                npm run build
              else
                # For development, include source maps
                GENERATE_SOURCEMAP=true npm run build
              fi
              ;;
            nextjs|nuxtjs)
              npm run build
              ;;
            python)
              if [ -f "setup.py" ]; then
                pip install wheel && python setup.py bdist_wheel
              fi
              ;;
            java-maven)
              if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                mvn clean package -Pprod -DskipTests
              else
                mvn clean package -Pdev -DskipTests
              fi
              ;;
            java-gradle)
              if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                ./gradlew clean build -Pprod -x test
              else
                ./gradlew clean build -Pdev -x test
              fi
              ;;
            golang)
              go build -v ./...
              ;;
            dotnet)
              if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                dotnet build --configuration Release
              else
                dotnet build --configuration Debug
              fi
              ;;
            rust)
              if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                cargo build --release
              else
                cargo build
              fi
              ;;
            php)
              if [ -f "composer.json" ] && grep -q "scripts" composer.json && grep -q "build" composer.json; then
                composer run-script build
              fi
              ;;
            generic)
              if [ -f "Makefile" ]; then
                make build
              elif [ -f "build.sh" ]; then
                bash build.sh
              else
                echo "No standard build process detected for generic project"
              fi
              ;;
          esac
          
          echo "Build completed successfully"

      # ---- CONTAINERIZATION ----
      - name: Set up Docker Buildx
        if: env.CONTAINERIZED == 'true'
        uses: docker/setup-buildx-action@v2
        
      - name: Login to Container Registry
        if: env.CONTAINERIZED == 'true'
        uses: docker/login-action@v2
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Build and push Docker image
        if: env.CONTAINERIZED == 'true'
        id: docker_build
        uses: docker/build-push-action@v4
        with:
          context: .
          push: ${{ env.ENVIRONMENT != 'development' }}  # Only push for non-dev environments
          tags: |
            ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}:${{ github.sha }}
            ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}:${{ env.ENVIRONMENT == 'production' && 'latest' || env.ENVIRONMENT }}
          build-args: |
            ENV=${{ env.ENVIRONMENT }}
            API_URL=${{ env.API_URL }}
            CDN_URL=${{ env.CDN_URL }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ---- TESTING ----
      - name: Run tests
        id: tests
        continue-on-error: true  # Continue workflow even if tests fail, but mark step as failed
        run: |
          echo "Running tests for ${{ env.PROJECT_TYPE }}"
          
          case ${{ env.PROJECT_TYPE }} in
            nodejs|angular|nextjs|nuxtjs)
              if grep -q "test" package.json; then
                npm test
              fi
              ;;
            python)
              if [ -f "pytest.ini" ] || [ -d "tests" ]; then
                pip install pytest pytest-cov && pytest --cov=./ --cov-report=xml
              elif [ -f "setup.py" ]; then
                python setup.py test
              fi
              ;;
            java-maven)
              mvn test
              ;;
            java-gradle)
              ./gradlew test
              ;;
            golang)
              go test ./... -v
              ;;
            dotnet)
              dotnet test
              ;;
            rust)
              cargo test
              ;;
            php)
              if [ -f "phpunit.xml" ] || [ -f "phpunit.xml.dist" ]; then
                vendor/bin/phpunit
              fi
              ;;
            generic)
              if [ -f "Makefile" ]; then
                make test
              elif [ -f "test.sh" ]; then
                bash test.sh
              else
                echo "No standard test process detected for generic project"
              fi
              ;;
          esac
          
          # Check if tests succeeded and set output
          if [ $? -eq 0 ]; then
            echo "tests_passed=true" >> $GITHUB_OUTPUT
          else
            echo "tests_passed=false" >> $GITHUB_OUTPUT
            echo "::warning::Tests failed. Review test results before production deployment."
          fi

      # ---- SECURITY SCANNING ----
      - name: Run security scanning
        id: security
        continue-on-error: true  # Continue workflow even if security issues found, but mark step as failed
        run: |
          echo "Running security scanning for ${{ env.PROJECT_TYPE }}"
          
          # Install and run appropriate security scanners based on project type
          case ${{ env.PROJECT_TYPE }} in
            nodejs|angular|nextjs|nuxtjs)
              npm install -g snyk
              snyk test || echo "Security vulnerabilities found"
              
              # If production, enforce stricter security rules
              if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                npm audit --production || echo "::warning::Production security audit failed"
              else
                npm audit || echo "::warning::Security audit found issues"
              fi
              ;;
            python)
              pip install bandit safety
              bandit -r . || echo "::warning::Bandit found security issues"
              safety check || echo "::warning::Safety found dependency vulnerabilities"
              ;;
            java-maven|java-gradle)
              # Example for Java projects
              if [[ "${{ env.PROJECT_TYPE }}" == "java-maven" ]]; then
                mvn org.owasp:dependency-check-maven:check || echo "::warning::OWASP dependency check found issues"
              else
                ./gradlew dependencyCheckAnalyze || echo "::warning::OWASP dependency check found issues"
              fi
              ;;
            # Add cases for other project types
          esac
          
          # Generic container security scan if containerized
          if [[ "${{ env.CONTAINERIZED }}" == "true" ]]; then
            # Example: Scan container image with Trivy
            echo "Scanning container image for vulnerabilities"
            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}:${{ github.sha }} || echo "::warning::Container vulnerabilities found"
          fi

      # ---- REPORT AND NOTIFICATION ----
      - name: Generate report and send notification
        if: always()  # Run this step regardless of previous step status
        run: |
          echo "Generating build report"
          
          # Create a summary report
          echo "# Build and Test Summary" > build-report.md
          echo "- Project Type: ${{ env.PROJECT_TYPE }}" >> build-report.md
          echo "- Environment: ${{ env.ENVIRONMENT }}" >> build-report.md
          echo "- Branch: ${{ github.ref }}" >> build-report.md
          echo "- Commit: ${{ github.sha }}" >> build-report.md
          echo "- Containerized: ${{ env.CONTAINERIZED }}" >> build-report.md
          echo "- Build Status: ${{ steps.build.outcome }}" >> build-report.md
          echo "- Test Status: ${{ steps.tests.outcome }}" >> build-report.md
          echo "- Security Status: ${{ steps.security.outcome }}" >> build-report.md
          
          # Check if any critical steps failed
          if [[ "${{ steps.build.outcome }}" == "failure" ]]; then
            echo "::error::Build process failed"
            echo "## :x: Build Failed" >> build-report.md
          fi
          
          if [[ "${{ steps.tests.outcome }}" == "failure" ]]; then
            echo "::warning::Tests failed"
            echo "## :warning: Tests Failed" >> build-report.md
          fi
          
          if [[ "${{ steps.security.outcome }}" == "failure" ]]; then
            echo "::warning::Security issues detected"
            echo "## :warning: Security Scan Found Issues" >> build-report.md
          fi
          
          # Send notification based on environment and status
          if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
            echo "Sending detailed notification for production deployment"
            # In a real scenario, this might call a dedicated notification service
            # or use GitHub Actions like slack-notify or email-action
          else
            echo "Sending standard notification for ${{ env.ENVIRONMENT }} deployment"
          fi
          
          cat build-report.md

      # ---- DEPLOYMENT ----
      - name: Check deployment conditions
        id: deploy-check
        run: |
          # Don't deploy if build failed
          if [[ "${{ steps.build.outcome }}" == "failure" ]]; then
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "::error::Deployment skipped due to build failure"
            exit 0
          fi
          
          # For production, require passing tests and security scans
          if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
            if [[ "${{ steps.tests.outcome }}" == "failure" || "${{ steps.security.outcome }}" == "failure" ]]; then
              echo "deploy=false" >> $GITHUB_OUTPUT
              echo "::error::Production deployment skipped due to failed tests or security issues"
              exit 0
            fi
          fi
          
          echo "deploy=true" >> $GITHUB_OUTPUT
          
      - name: Deploy application
        if: steps.deploy-check.outputs.deploy == 'true'
        run: |
          echo "Deploying to ${{ env.ENVIRONMENT }} using ${{ env.DEPLOY_STRATEGY }} strategy"
          
          # Setup deployment tools based on environment
          if [[ "${{ env.ENVIRONMENT }}" == "production" || "${{ env.ENVIRONMENT }}" == "staging" ]]; then
            # For prod/staging, we might use more advanced tools
            echo "Setting up production-grade deployment tools"
          else
            echo "Setting up standard deployment tools"
          fi
          
          # Deploy using the appropriate strategy for the environment
          case ${{ env.DEPLOY_STRATEGY }} in
            blue-green)
              echo "Performing blue-green deployment"
              # In a real scenario, this would:
              # 1. Deploy to inactive environment
              # 2. Run smoke tests
              # 3. Switch traffic
              # 4. Monitor for issues
              ;;
            canary)
              echo "Performing canary deployment"
              # In a real scenario, this would:
              # 1. Deploy to a small subset of instances
              # 2. Monitor for issues
              # 3. Gradually increase traffic
              ;;
            rolling)
              echo "Performing rolling deployment"
              # In a real scenario, this would:
              # 1. Deploy to instances in batches
              # 2. Wait for health checks before proceeding
              ;;
          esac
          
          # Simulate deployment based on project type and containerization
          if [[ "${{ env.CONTAINERIZED }}" == "true" ]]; then
            echo "Deploying containerized application to ${{ env.ENVIRONMENT }}"
            # Example: Deploy to Kubernetes or other container platform
          else
            echo "Deploying non-containerized application to ${{ env.ENVIRONMENT }}"
            # Example: Deploy to traditional hosting
          fi
          
          echo "Deployment to ${{ env.ENVIRONMENT }} completed successfully"

      # ---- POST-DEPLOYMENT MONITORING AND LOGGING ----
      - name: Configure monitoring and logging
        if: steps.deploy-check.outputs.deploy == 'true'
        run: |
          echo "Setting up monitoring and logging for ${{ env.ENVIRONMENT }}"
          
          # Setup Prometheus monitoring
          if [[ "${{ env.MONITORING_TOOL }}" == "prometheus" ]]; then
            echo "Setting up Prometheus monitoring"
            
            # Clone Prometheus operator repository
            git clone https://github.com/prometheus-operator/kube-prometheus.git
            cd kube-prometheus
            
            # Apply Prometheus configurations based on environment
            if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
              # Apply production-grade monitoring with longer retention periods
              sed -i 's/retention: 24h/retention: 30d/' manifests/prometheus-prometheus.yaml
              # Adjust alert thresholds for production
              sed -i 's/threshold: 0.90/threshold: 0.95/' manifests/prometheus-rules.yaml
            else
              # Apply development/testing monitoring with shorter retention
              sed -i 's/retention: 24h/retention: 3d/' manifests/prometheus-prometheus.yaml
            fi
            
            # Apply Prometheus configurations
            kubectl apply -f manifests/setup
            kubectl apply -f manifests/
            
            cd ..
            
            # Set up Grafana dashboards
            echo "Setting up Grafana dashboards"
            kubectl apply -f monitoring/grafana-dashboards/
            
            # Configure service monitors for the application
            cat <<EOF > app-service-monitor.yaml
            apiVersion: monitoring.coreos.com/v1
            kind: ServiceMonitor
            metadata:
              name: ${{ github.event.repository.name }}-monitor
              namespace: monitoring
            spec:
              selector:
                matchLabels:
                  app: ${{ github.event.repository.name }}
              endpoints:
              - port: metrics
                interval: 15s
            EOF
            
            kubectl apply -f app-service-monitor.yaml
          elif [[ "${{ env.MONITORING_TOOL }}" == "azure-monitor" ]]; then
            echo "Setting up Azure Monitor"
            # Configure Application Insights
            az monitor app-insights component create --app ${{ github.event.repository.name }}-insights --location eastus --resource-group myresourcegroup --application-type web
          fi
          
          # Setup ELK Stack for logging
          if [[ "${{ env.LOGGING_TOOL }}" == "elk" ]]; then
            echo "Setting up ELK Stack logging"
            
            # Apply ELK configurations based on environment
            if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
              # Configure production log retention and sampling policies
              kubectl apply -f logging/elasticsearch/production-values.yaml
              # Set up index lifecycle management
              kubectl apply -f logging/elasticsearch/ilm-policy.yaml
            else
              # Configure development log retention
              kubectl apply -f logging/elasticsearch/development-values.yaml
            fi
            
            # Apply Filebeat configurations for log collection
            kubectl apply -f logging/filebeat/filebeat-kubernetes.yaml
            
            # Apply Kibana configurations
            kubectl apply -f logging/kibana/kibana.yaml
            
            # Create log retention policy
            echo "Configuring log retention and sampling policies"
            # In a real scenario, this would create specific log retention policies
          fi
          
          # Setup notification channels
          if [[ "${{ env.NOTIFICATION_CHANNEL }}" == "slack" ]]; then
            echo "Setting up Slack notifications"
            
            # Install Slack CLI
            npm install -g slack-cli
            
            # Configure Slack webhook
            export SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}
            
            # Send deployment notification
            slack-cli -h ${{ secrets.SLACK_CHANNEL }} "🚀 Deployment Update: ${{ github.event.repository.name }} has been deployed to ${{ env.ENVIRONMENT }} environment. Commit: ${{ github.sha }}"
            
            # Configure alert thresholds to avoid notification spam
            if [[ "${{ env.MONITORING_TOOL }}" == "prometheus" ]]; then
              # Adjust Alertmanager configuration
              cat <<EOF > alertmanager-config.yaml
              global:
                resolve_timeout: 5m
                slack_api_url: '${{ secrets.SLACK_WEBHOOK_URL }}'
              
              route:
                group_by: ['alertname', 'job']
                group_wait: 30s
                group_interval: 5m
                repeat_interval: 4h
                receiver: 'slack-notifications'
                routes:
                - match:
                    severity: critical
                  receiver: 'slack-critical'
                  repeat_interval: 1h
              
              receivers:
              - name: 'slack-notifications'
                slack_configs:
                - channel: '#${{ secrets.SLACK_CHANNEL }}'
                  send_resolved: true
                  title: '{{ template "slack.default.title" . }}'
                  text: '{{ template "slack.default.text" . }}'
              - name: 'slack-critical'
                slack_configs:
                - channel: '#${{ secrets.SLACK_CRITICAL_CHANNEL }}'
                  send_resolved: true
                  title: '🚨 {{ template "slack.default.title" . }}'
                  text: '{{ template "slack.default.text" . }}'
              EOF
              
              kubectl create secret generic alertmanager-config --from-file=alertmanager.yaml=alertmanager-config.yaml -n monitoring --dry-run=client -o yaml | kubectl apply -f -
              kubectl rollout restart deployment alertmanager-main -n monitoring
            fi
          fi
          
          echo "Performing post-deployment health check"
          # Call health check endpoint to verify deployment
          curl -f http://myapp-health-endpoint/health || echo "Health check failed"
          
          # Record deployment in deployment history
          echo "Recording deployment information"
          echo "Deployed version ${{ github.sha }} to ${{ env.ENVIRONMENT }} at $(date)" >> deployment-history.txt
          
          # Setup right-sizing for resources
          echo "Configuring resource optimization"
          if [[ "${{ env.ENVIRONMENT }}" != "production" ]]; then
            echo "Setting up auto-shutdown for non-production environments"
            # In a real scenario, this would:
            # 1. Configure auto-shutdown during non-working hours
            # 2. Right-size resources based on expected usage
            # 3. Set up scaling policies
            
            if [[ "${{ env.CLOUD_PROVIDER }}" == "azure" ]]; then
              # Set up auto-shutdown for Azure resources
              az vm auto-shutdown -g myresourcegroup -n myvm --time 1900
            elif [[ "${{ env.CLOUD_PROVIDER }}" == "aws" ]]; then
              # Set up AWS auto-scaling with scheduled actions
              aws autoscaling put-scheduled-update-group-action --auto-scaling-group-name my-asg --scheduled-action-name night-scale-down --start-time "2025-01-01T19:00:00Z" --recurrence "0 19 * * *" --min-size 0 --max-size 0 --desired-capacity 0
            fi
          fi